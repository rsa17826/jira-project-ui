<!doctype html>
<html>
  <head>
    <title>Jira API Test</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <button
      id="toggleSelf"
      onclick="
        localStorage.lastSelfShownState = !(
          localStorage.lastSelfShownState === 'true'
        )
        toggleShowOnlySelf(this)
      "
      onload="toggleShowOnlySelf(this)"
    ></button>
    <pre id="output"></pre>
    <script src="./js globals/libloader.js"></script>
    <script src="./js globals/allfuncs.js"></script>
    <script src="./js globals/log.js"></script>
    <script src="./token.js"></script>
    <svg
      id="arrowsLayer"
      style="
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 0;
      "
    >
      <defs>
        <marker
          id="arrowhead"
          markerWidth="10"
          markerHeight="7"
          refX="10"
          refY="3.5"
          orient="auto"
          markerUnits="strokeWidth"
        >
          <polygon points="0 0, 10 3.5, 0 7" fill="context-stroke" />
        </marker>
      </defs>
    </svg>
    <script>
      const a = loadlib("allfuncs")
      let rootBlockers = new Set()
      var uname = null
      var email = null
      var tasks = {}
      toggleShowOnlySelf(a.qs("#toggleSelf"))

      function toggleShowOnlySelf(self) {
        showOnlySelf(localStorage.lastSelfShownState === "true")
        log(self)
        self.textContent =
          localStorage.lastSelfShownState === "true" ?
            "show all tasks"
          : "show only own tasks"
      }
      function isBlockingMyTask(taskKey) {
        return Object.values(tasks).some(
          (t) =>
            t.assignee === uname &&
            t.blockedBy &&
            t.blockedBy.includes(taskKey),
        )
      }
      // var assigneeDict = {}
      async function getSubtasks() {
        const jql = `
          project = "${currentProject}"
          AND issuetype IN subTaskIssueTypes()
          ORDER BY created DESC
        `

        const res = await globalrequest({
          url: `https://${domain}/rest/api/3/search/jql?jql=${encodeURIComponent(jql)}&maxResults=100&fields=summary,status,assignee,parent,issuetype,priority,issuelinks,attachment`,
          method: "GET",
          headers: {
            Authorization: "Basic " + btoa(email + ":" + apiToken),
            Accept: "application/json",
          },
        })

        const data = JSON.parse(res.text)

        const subtasks = data.issues
          .filter((issue) => issue.fields.issuetype.subtask)
          .map((issue) => {
            const { blocks, blockedBy } = extractBlockInfo(issue)
            log(issue)
            const attachments = (issue.fields.attachment || []).map(
              (att) => ({
                id: att.id,
                filename: att.filename,
                mimeType: att.mimeType,
                size: att.size,
                url: att.content, // direct link to file
                author: att.author?.displayName,
                created: att.created,
              }),
            )

            return {
              key: issue.key,
              summary: issue.fields.summary,
              status: issue.fields.status?.name,
              statusCategory:
                issue.fields.status?.statusCategory?.name,
              assignee: issue.fields.assignee?.displayName,
              assigneeUrl: unescape(
                Object.values(
                  issue.fields.assignee?.avatarUrls ?? [],
                )?.[0]?.match?.(
                  /https?:\/\/secure\.gravatar\.com\/avatar\/[\w\d]+\?d=([^&]+)/,
                )?.[1],
              ),
              parent: issue.fields.parent?.key,
              priority: issue.fields.priority?.name,
              blocks,
              blockedBy,
              attachments,
            }
          })
          .sort(
            (a, s) =>
              Number(a.key.replace(/^T\d+-/, "")) -
              Number(s.key.replace(/^T\d+-/, "")),
          )
        const doneKeys = new Set()
        for (const task of subtasks) {
          if (task.statusCategory === "Done") {
            doneKeys.add(task.key)
          }
        }

        for (const task of subtasks) {
          if (doneKeys.has(task.key)) {
            task.blocks = []
            task.blockedBy = []
          } else {
            task.blocks = task.blocks.filter((k) => !doneKeys.has(k))
            task.blockedBy = task.blockedBy.filter(
              (k) => !doneKeys.has(k),
            )
          }
        }
        // .filter(
        //   (e) =>
        //     e.status !== "In Review" &&
        //     e.status !== "Done"
        // )
        // for (var st of subtasks) {
        //   assigneeDict[st.assignee] = {
        //     assignee: st.assignee,
        //     assigneeUrl: st.assigneeUrl,
        //   }
        // }
        for (var v of subtasks) {
          v.assigneeUrl =
            imageReplaces[
              v.assigneeUrl
                .replace(
                  "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/initials/",
                  "",
                )
                .replace(/-\d+\.png$/, "")
            ] ?? v.assigneeUrl
          tasks[v.key] = v
        }
        rootBlockers = getRootBlockersOfMine()
        a.qs("#output").innerHTML = ""
        subtasks.forEach((e) =>
          a.qs("#output").appendChild(showTask(e)),
        )
        if (localStorage.lastSelfShownState === "true")
          toggleShowOnlySelf(a.qs("#toggleSelf"))
        drawAllDependencies()
      }
      //     function showTask({ key, assignee, status, summary, parent }) {
      //       return `
      //   <div class="task">
      //     <h3>${key}</h3>
      //     <strong>Summary:</strong> ${summary || "(No summary)"}
      //     <strong>Status:</strong> ${status}
      //     <strong>Assignee:</strong> ${assignee || "Unassigned"}
      //     <strong>Parent:</strong> ${parent}
      //     <a href="https://itp251.atlassian.net/jira/software/projects/T1/boards/67?selectedIssue=${key}">asd</a>
      //     <hr>
      //   </div>
      // `
      //     }
      function extractBlockInfo(issue) {
        const links = issue.fields.issuelinks || []

        const blocks = []
        const blockedBy = []

        links.forEach((link) => {
          if (link.type?.name === "Blocks") {
            if (link.outwardIssue) {
              // This issue BLOCKS another issue
              blocks.push(link.outwardIssue.key)
            }

            if (link.inwardIssue) {
              // This issue IS BLOCKED BY another issue
              blockedBy.push(link.inwardIssue.key)
            }
          }
        })

        return { blocks, blockedBy }
      }
      async function getCurrentUser() {
        const response = await globalrequest({
          url: `https://${domain}/rest/api/3/myself`,
          method: "GET",
          headers: {
            Authorization: "Basic " + btoa(email + ":" + apiToken),
            Accept: "application/json",
          },
        })

        if (response.status !== 200) {
          throw new Error("Failed to get current user")
        }

        const data = JSON.parse(response.text)
        return {
          username: data.name || data.displayName || null,
          displayName: data.displayName || null,
          accountId: data.accountId || null,
        }
      }
      function showOnlySelf(on) {
        a.qsa(".task").map(
          (e) =>
            (e.style.display =
              (
                !on ||
                uname ==
                  tasks[e.getAttribute("data-task-key")].assignee
              ) ?
                "block"
              : "none"),
        )
        drawAllDependencies()
      }
      function getRootBlockersOfMine() {
        const roots = new Set()

        function findRoots(taskKey, visited = new Set()) {
          if (visited.has(taskKey)) return
          visited.add(taskKey)

          const task = tasks[taskKey]
          if (
            !task ||
            !task.blockedBy ||
            task.blockedBy.length === 0
          ) {
            roots.add(taskKey)
            return
          }

          task.blockedBy.forEach((parentKey) => {
            findRoots(parentKey, visited)
          })
        }

        // For each of your tasks
        Object.values(tasks).forEach((task) => {
          if (task.assignee === uname) {
            findRoots(task.key)
          }
        })

        return roots
      }
      async function getAttachmentImage(url) {
        const res = await globalrequest(url, {
          responseType: "blob",
          headers: {
            Authorization: "Basic " + btoa(email + ":" + apiToken),
          },
        })
        return URL.createObjectURL(res.response) // local URL to use in <img>
      }

      function showTask(task) {
        const jiraUrl = `https://${domain}/browse/${task.key}`
        const isRootBlocker = rootBlockers.has(task.key)
        const isBlocked = task.blockedBy.length > 0
        const isMine = task.assignee === uname
        // const isBlockingMine = isBlockingMyTask(task.key)
        const glowClass =
          isRootBlocker ? "blocking-mine"
          : isMine ? "mine"
          : ""
        let statusClass = "todo"
        if (task.statusCategory === "In Progress")
          statusClass = "progress"
        else if (task.statusCategory === "Done") statusClass = "done"

        return a.newelem(
          "div",
          {
            class: [
              "task",
              statusClass,
              isBlocked && "blocker",
              glowClass,
            ].filter(Boolean),
            dataset: { taskKey: task.key },
          },
          [
            a.newelem(
              "a",
              {
                class: "jira-link",
                href: jiraUrl,
                target: "_blank",
              },
              [task.key],
            ),
            isBlocked &&
              a.newelem("div", { class: "blocked-section" }, [
                "ðŸš¨ Blocked by: ",
                ...task.blockedBy.flatMap((key, i) => {
                  const blocker = tasks[key]
                  const name = blocker?.assignee || "Unknown"
                  const avatar = blocker?.assigneeUrl || "about:blank"
                  return [
                    a.newelem(
                      "a",
                      {
                        href: `https://${domain}/browse/${key}`,
                        target: "_blank",
                        class: "blocker-link",
                      },
                      [
                        key,
                        a.newelem("img", {
                          src: avatar,
                          class: "avatar",
                          width: 20,
                          height: 20,
                          alt: name,
                          title: name,
                          style: {
                            verticalAlign: "middle",
                            borderRadius: "50%",
                            marginLeft: "4px",
                          },
                        }),
                      ],
                    ),
                    i < task.blockedBy.length - 1 ? ", " : null,
                  ]
                }),
              ]),
            a.newelem("div", { class: "summary" }, [task.summary]),
            a.newelem("div", {}, [
              a.newelem("strong", {}, ["Status:"]),
              " ",
              task.status,
            ]),
            a.newelem("div", {}, [
              a.newelem("strong", {}, ["Assignee:"]),
              " ",
              task.assignee || "Unassigned",
              " ",
              task.assigneeUrl &&
                a.newelem("img", {
                  src: task.assigneeUrl,
                  width: 18,
                  height: 18,
                  style: {
                    verticalAlign: "middle",
                    marginLeft: "-2px",
                    borderRadius: "50%",
                  },
                }),
            ]),
            a.newelem("div", {}, [
              a.newelem("strong", {}, ["Parent:"]),
              " ",
              task.parent,
            ]),
            task.attachments.length ?
              a.newelem("div", { class: "attachments" }, [
                task.attachments.map((att, idx) => {
                  var img = a.newelem(
                    "img",
                    {
                      width: "100px",
                      maxHeight: "300px",
                    },
                    [],
                  )
                  getAttachmentImage(att.url).then((url) => {
                    img.parentElement.href = url
                    img.src = url
                    drawAllDependencies()
                  })
                  return a.newelem(
                    "a",
                    {
                      href: att.url,
                      target: "_blank",
                      download: task.key + " #" + (idx + 1),
                    },
                    [img],
                  )
                }),
              ])
            : null,
          ].filter(Boolean),
        )
      }
      async function getAllProjects() {
        const res = await globalrequest({
          url: `https://${domain}/rest/api/3/project/search`,
          method: "GET",
          headers: {
            Authorization: "Basic " + btoa(email + ":" + apiToken),
            Accept: "application/json",
          },
        })

        return JSON.parse(res.text).values
      }
      async function getProjectStatuses(projectId) {
        const res = await globalrequest({
          url: `https://${domain}/rest/api/3/project/${projectId}/statuses`,
          method: "GET",
          headers: {
            Authorization: "Basic " + btoa(email + ":" + apiToken),
            Accept: "application/json",
          },
        })

        return JSON.parse(res.text)
      }
      async function getProjectAssignees(projectKey) {
        const jql = `project = "${projectKey}" AND assignee IS NOT EMPTY`

        const res = await globalrequest({
          url: `https://${domain}/rest/api/3/search/jql?jql=${encodeURIComponent(
            jql,
          )}&fields=assignee&maxResults=100`,
          method: "GET",
          headers: {
            Authorization: "Basic " + btoa(email + ":" + apiToken),
            Accept: "application/json",
          },
        })

        const data = JSON.parse(res.text)

        const assignees = new Map()

        data.issues.forEach((issue) => {
          const user = issue.fields.assignee
          if (user) {
            assignees.set(user.accountId, user.displayName)
          }
        })

        return Array.from(assignees.values())
      }
      function getTaskCenter(el) {
        const rect = el.getBoundingClientRect()
        return {
          x: rect.left + rect.width / 2 + window.scrollX,
          y: rect.top + rect.height / 2 + window.scrollY,
        }
      }
      function hashStringToInt(str) {
        let hash = 0
        for (let i = 0; i < str.length; i++) {
          hash = (hash * 31 + str.charCodeAt(i)) >>> 0
        }
        return hash
      }
      function getEdgePoint(fromEl, toEl) {
        const rectFrom = fromEl.getBoundingClientRect()
        const rectTo = toEl.getBoundingClientRect()
        const inset = 0 // 10px inside the div

        // Compute horizontal/vertical centers
        const fromCenterX =
          rectFrom.left + rectFrom.width / 2 + window.scrollX
        const fromCenterY =
          rectFrom.top + rectFrom.height / 2 + window.scrollY
        const toCenterX =
          rectTo.left + rectTo.width / 2 + window.scrollX
        const toCenterY =
          rectTo.top + rectTo.height / 2 + window.scrollY

        let x, y

        const dx = toCenterX - fromCenterX
        const dy = toCenterY - fromCenterY
        const absDx = Math.abs(dx)
        const absDy = Math.abs(dy)
        var side
        if (absDx > absDy) {
          // horizontal connection
          x =
            dx > 0 ?
              rectFrom.right - inset + window.scrollX
            : rectFrom.left + inset + window.scrollX
          y = fromCenterY
          side = "x"
        } else {
          // vertical connection
          side = "y"
          x = fromCenterX
          y =
            dy > 0 ?
              rectFrom.bottom - inset + window.scrollY
            : rectFrom.top + inset + window.scrollY
        }

        return { x, y, side }
      }
      function drawArrowEdge(fromEl, toEl, taskKey) {
        const svg = document.getElementById("arrowsLayer")

        const start = getEdgePoint(fromEl, toEl)
        const end = getEdgePoint(toEl, fromEl) // target inset

        // perpendicular offset (smaller for short lines, bigger for longer)
        // const offset = Math.min(50, Math.sqrt(dx * dx + dy * dy) / 3)
        const rect = fromEl.getBoundingClientRect()
        const path = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "path",
        )
        const seed = hashStringToInt(taskKey) // convert ID to number

        if (start.side === "x") {
          end.y += randomIntFromSeed(
            seed,
            -rect.height / 2,
            rect.height / 2,
          ) // different for end
        } else {
          end.x += randomIntFromSeed(
            seed,
            -rect.width / 2,
            rect.width / 2,
          )
        }
        path.setAttribute(
          "d",
          `M ${start.x},${start.y} ${end.x},${end.y}`,
        )
        // path.setAttribute("stroke", "#de350b")
        path.setAttribute(
          "stroke",
          getComputedStyle(toEl)
            .borderLeftColor.replace("rgb", "rgba")
            .replace(")", ", .5)"),
        )
        path.setAttribute("stroke-width", "2")
        path.setAttribute("fill", "none")
        path.setAttribute("marker-end", "url(#arrowhead)")

        svg.appendChild(path)
      }
      function drawAllDependencies() {
        const svg = a.qs("#arrowsLayer")
        svg.style.height =
          document.documentElement.scrollHeight + "px"
        svg.innerHTML = svg.querySelector("defs").outerHTML // reset but keep arrowhead

        document.querySelectorAll(".task").forEach((taskDiv) => {
          const taskKey = taskDiv.getAttribute("data-task-key")
          const task = tasks[taskKey]

          if (!task.blockedBy || task.blockedBy.length === 0) return

          var blockerLinks = a.qsa(".blocker-link", taskDiv)
          task.blockedBy.forEach((blockerKey) => {
            const blockerDiv = document.querySelector(
              `[data-task-key="${blockerKey}"]`,
            )
            if (blockerDiv)
              drawArrowEdge(
                blockerLinks.find((e) => e.textContent == blockerKey),
                blockerDiv,
                taskDiv.getAttribute("data-task-key"),
              ) // blocked â†’ blocker
          })
        })
      }
      window.addEventListener("resize", drawAllDependencies)
      function mulberry32(seed) {
        return function () {
          seed |= 0
          seed = (seed + 0x6d2b79f5) | 0
          let t = Math.imul(seed ^ (seed >>> 15), 1 | seed)
          t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t
          return ((t ^ (t >>> 14)) >>> 0) / 4294967296
        }
      }

      function randomIntFromSeed(seed, min, max) {
        return Math.floor(mulberry32(seed)() * (max - min + 1)) + min
      }

      ;(async () => {
        await a.waituntil(() => window.globalrequest)

        localStorage.lastSelfShownState ??= "false"
        getCurrentUser().then((e) => {
          uname = e.displayName
          email = e.emailAddress
          getSubtasks()
        })
      })()
    </script>
  </body>
</html>
