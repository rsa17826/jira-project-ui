<!doctype html>
<html>
  <head>
    <title>Jira API Test</title>
    <style>
      .task {
        padding: 8px 12px; /* a bit tighter padding */
        margin-bottom: 8px; /* less vertical space between tasks */
        border-radius: 6px;
        border-left: 6px solid;
        background: #f4f6f8;
        font-family: Arial, sans-serif;
        /* line-height: 0.7; */
      }

      .jira-link {
        text-decoration: none;
        font-weight: bold;
        color: #0747a6;
        display: inline-block;
        margin-bottom: 2px;
      }

      .blocked {
        color: #de350b;
        font-weight: bold;
      }

      /* Reduce spacing for the detail lines */
      .task > div {
        margin: 2px 0;
      }

      .todo {
        border-color: #6b778c;
      }
      .progress {
        border-color: #ffab00;
      }
      .done {
        border-color: #36b37e;
      }

      .blocker {
        border-color: #de350b !important;
        background: #ffebe6;
      }

      .blocked {
        color: #de350b;
        font-weight: bold;
      }

      .blocking {
        color: #bf2600;
      }
      #output {
        display: flex; /* horizontal layout */
        flex-wrap: wrap; /* wrap to next line if too wide */
        gap: 12px; /* space between tasks */
      }
      body {
        background-color: #1e1e1e;
        color: #e0e0e0;
        font-family: Arial, sans-serif;
      }

      .task {
        flex: 0 0 auto; /* prevent stretching */
        min-width: 250px; /* optional: minimum task width */
        padding: 8px 12px;
        border-radius: 6px;
        border-left: 6px solid;
        background: #f4f6f8;
        line-height: 1.3;
        background-color: #121212;
      }
      body {
        background-color: #1e1e1e;
        color: #e0e0e0;
        font-family: Arial, sans-serif;
      }

      #taskContainer {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        padding: 12px;
        background-color: #121212;
      }
      button {
        background-color: #777;
        border: 2px solid #666;
        border-radius: 120px;
      }
      /* Task cards */
      .task {
        flex: 0 0 auto;
        min-width: 250px;
        padding: 12px;
        border-radius: 8px;
        background-color: #00000000;
        border-left: 6px solid;
        line-height: 1.3;
        color: #e0e0e0;
      }

      .task.todo {
        --c: #3880ff;
      } /* blue-gray / To Do */
      .task.progress {
        --c: #ffb400;
      } /* yellow / In Progress */
      .task.done {
        --c: #28a745;
      } /* green / Done */
      .task.blocker {
        --c: #de350b;
      }

      .task {
        border-left: 6px solid var(--c);
        background-color: color-mix(
          in srgb,
          var(--c) 20%,
          #1e1e1e 80%
        );
      }

      /* .task.blocker {
        box-shadow: 0 0 12px #a00;
      } */

      /* Jira links */
      .jira-link,
      .blocked a {
        color: #74b9ff;
        text-decoration: none;
      }
      .jira-link:hover,
      .blocked a:hover {
        text-decoration: underline;
      }

      /* Blocked section */
      .blocked {
        color: #ff6b6b;
        font-weight: bold;
        margin: 4px 0;
      }

      /* Avatars inline */
      .task img {
        vertical-align: middle;
        margin-left: 6px;
        border-radius: 50%;
        border: 1px solid #555;
      }

      /* Tooltip for issue previews */
      .tooltip {
        position: absolute;
        background: #333;
        color: #e0e0e0;
        border: 1px solid #555;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 14px;
        max-width: 300px;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s ease-in-out;
        z-index: 1000;
      }
      .tooltip.visible {
        opacity: 1;
      }
      .tooltip .spinner {
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 3px solid #555;
        border-top-color: #74b9ff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        vertical-align: middle;
        margin-left: 6px;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <button
      id="toggleSelf"
      onclick="
        localStorage.lastSelfShownState = !(
          localStorage.lastSelfShownState === 'true'
        )
        toggleShowOnlySelf(this)
      "
      onload="toggleShowOnlySelf(this)"
    ></button>
    <pre id="output"></pre>
    <script src="./js globals/libloader.js"></script>
    <script src="./js globals/allfuncs.js"></script>
    <script src="./js globals/log.js"></script>
    <script src="./token.js"></script>
    <svg
      id="arrowsLayer"
      style="
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 0;
      "
    >
      <defs>
        <marker
          id="arrowhead"
          markerWidth="10"
          markerHeight="7"
          refX="10"
          refY="3.5"
          orient="auto"
          markerUnits="strokeWidth"
        >
          <polygon points="0 0, 10 3.5, 0 7" fill="red" />
        </marker>
      </defs>
    </svg>
    <script>
      const a = loadlib("allfuncs")
      var uname = null
      var email = null
      var tasks = {}
      localStorage.lastSelfShownState ??= "true"
      toggleShowOnlySelf(a.qs("#toggleSelf"))

      function toggleShowOnlySelf(self) {
        showOnlySelf(localStorage.lastSelfShownState === "true")
        log(self)
        self.textContent =
          localStorage.lastSelfShownState === "true" ?
            "show all tasks"
          : "show only own tasks"
      }
      getCurrentUser().then((e) => {
        uname = e.displayName
        email = e.emailAddress
        getSubtasks()
      })
      // var assigneeDict = {}
      async function getSubtasks() {
        const jql = `
          project = "${currentProject}"
          AND issuetype IN subTaskIssueTypes()
          ORDER BY created DESC
        `

        const res = await globalrequest({
          url: `https://${domain}/rest/api/3/search/jql?jql=${encodeURIComponent(jql)}&maxResults=100&fields=summary,status,assignee,parent,issuetype,priority,issuelinks`,
          method: "GET",
          headers: {
            Authorization: "Basic " + btoa(email + ":" + apiToken),
            Accept: "application/json",
          },
        })

        const data = JSON.parse(res.text)

        const subtasks = data.issues
          .filter((issue) => issue.fields.issuetype.subtask)
          .map((issue) => {
            const { blocks, blockedBy } = extractBlockInfo(issue)
            log(issue)
            return {
              key: issue.key,
              summary: issue.fields.summary,
              status: issue.fields.status?.name,
              statusCategory:
                issue.fields.status?.statusCategory?.name,
              assignee: issue.fields.assignee?.displayName,
              assigneeUrl: unescape(
                Object.values(
                  issue.fields.assignee?.avatarUrls ?? [],
                )?.[0]?.match?.(
                  /https?:\/\/secure\.gravatar\.com\/avatar\/[\w\d]+\?d=([^&]+)/,
                )?.[1],
              ),
              parent: issue.fields.parent?.key,
              priority: issue.fields.priority?.name,
              blocks,
              blockedBy,
            }
          })
          .sort(
            (a, s) =>
              Number(a.key.replace(/^T\d+-/, "")) -
              Number(s.key.replace(/^T\d+-/, "")),
          )
        // .filter(
        //   (e) =>
        //     e.status !== "In Review" &&
        //     e.status !== "Done"
        // )
        // for (var st of subtasks) {
        //   assigneeDict[st.assignee] = {
        //     assignee: st.assignee,
        //     assigneeUrl: st.assigneeUrl,
        //   }
        // }
        for (var v of subtasks) {
          v.assigneeUrl =
            imageReplaces[
              v.assigneeUrl
                .replace(
                  "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/initials/",
                  "",
                )
                .replace(/-\d+\.png$/, "")
            ] ?? v.assigneeUrl
          tasks[v.key] = v
        }
        a.qs("#output").innerHTML = subtasks.map(showTask).join("")
        if (localStorage.lastSelfShownState === "true")
          toggleShowOnlySelf(a.qs("#toggleSelf"))
        drawAllDependencies()
      }
      //     function showTask({ key, assignee, status, summary, parent }) {
      //       return `
      //   <div class="task">
      //     <h3>${key}</h3>
      //     <strong>Summary:</strong> ${summary || "(No summary)"}
      //     <strong>Status:</strong> ${status}
      //     <strong>Assignee:</strong> ${assignee || "Unassigned"}
      //     <strong>Parent:</strong> ${parent}
      //     <a href="https://itp251.atlassian.net/jira/software/projects/T1/boards/67?selectedIssue=${key}">asd</a>
      //     <hr>
      //   </div>
      // `
      //     }
      function extractBlockInfo(issue) {
        const links = issue.fields.issuelinks || []

        const blocks = []
        const blockedBy = []

        links.forEach((link) => {
          if (link.type?.name === "Blocks") {
            if (link.outwardIssue) {
              // This issue BLOCKS another issue
              blocks.push(link.outwardIssue.key)
            }

            if (link.inwardIssue) {
              // This issue IS BLOCKED BY another issue
              blockedBy.push(link.inwardIssue.key)
            }
          }
        })

        return { blocks, blockedBy }
      }
      async function getCurrentUser() {
        const response = await globalrequest({
          url: `https://${domain}/rest/api/3/myself`,
          method: "GET",
          headers: {
            Authorization: "Basic " + btoa(email + ":" + apiToken),
            Accept: "application/json",
          },
        })

        if (response.status !== 200) {
          throw new Error("Failed to get current user")
        }

        const data = JSON.parse(response.text)
        return {
          username: data.name || data.displayName || null,
          displayName: data.displayName || null,
          accountId: data.accountId || null,
        }
      }
      function showOnlySelf(on) {
        a.qsa(".task").map(
          (e) =>
            (e.style.display =
              (
                !on ||
                uname ==
                  tasks[e.getAttribute("data-task-key")].assignee
              ) ?
                "block"
              : "none"),
        )
        drawAllDependencies()
      }

      function showTask(task) {
        const jiraUrl = `https://${domain}/browse/${task.key}`
        const isBlocked = task.blockedBy.length > 0

        let statusClass = "todo"
        if (task.statusCategory === "In Progress")
          statusClass = "progress"
        else if (task.statusCategory === "Done") statusClass = "done"

        return `<div class="task ${statusClass} ${isBlocked ? "blocker" : ""}" data-task-key="${task.key}"><a 
class="jira-link" 
href="${jiraUrl}" 
target="_blank" 
>${task.key}</a>${
          isBlocked ?
            `
ðŸš¨ Blocked by: ${task.blockedBy
              .map((key) => {
                const blocker = tasks[key] // lookup in your dict
                const name = blocker?.assignee || "Unknown"
                const avatar = blocker?.assigneeUrl || "about:blank"
                return `<a href="https://${domain}/browse/${key}" target="_blank" class="blocker-link">${key} <img src="${avatar}" width="20" height="20" style="vertical-align: middle; border-radius:50%; margin-left:4px;" alt="${name}" title="${name}" /></a>`
              })
              .join(", ")}`
          : ""
        }
${task.summary}
<strong>Status:</strong> ${task.status}
<strong>Assignee:</strong> ${task.assignee || "Unassigned"} <img style='vertical-align: middle; margin-left: -2px; border-radius: 50%;' width=18px height=18px src="${task.assigneeUrl}"></img>
<strong>Parent:</strong> ${task.parent}</div>`
      }
      async function getAllProjects() {
        const res = await globalrequest({
          url: `https://${domain}/rest/api/3/project/search`,
          method: "GET",
          headers: {
            Authorization: "Basic " + btoa(email + ":" + apiToken),
            Accept: "application/json",
          },
        })

        return JSON.parse(res.text).values
      }
      async function getProjectStatuses(projectId) {
        const res = await globalrequest({
          url: `https://${domain}/rest/api/3/project/${projectId}/statuses`,
          method: "GET",
          headers: {
            Authorization: "Basic " + btoa(email + ":" + apiToken),
            Accept: "application/json",
          },
        })

        return JSON.parse(res.text)
      }
      async function getProjectAssignees(projectKey) {
        const jql = `project = "${projectKey}" AND assignee IS NOT EMPTY`

        const res = await globalrequest({
          url: `https://${domain}/rest/api/3/search/jql?jql=${encodeURIComponent(
            jql,
          )}&fields=assignee&maxResults=100`,
          method: "GET",
          headers: {
            Authorization: "Basic " + btoa(email + ":" + apiToken),
            Accept: "application/json",
          },
        })

        const data = JSON.parse(res.text)

        const assignees = new Map()

        data.issues.forEach((issue) => {
          const user = issue.fields.assignee
          if (user) {
            assignees.set(user.accountId, user.displayName)
          }
        })

        return Array.from(assignees.values())
      }
      function getTaskCenter(el) {
        const rect = el.getBoundingClientRect()
        return {
          x: rect.left + rect.width / 2 + window.scrollX,
          y: rect.top + rect.height / 2 + window.scrollY,
        }
      }
      function hashStringToInt(str) {
        let hash = 0
        for (let i = 0; i < str.length; i++) {
          hash = (hash * 31 + str.charCodeAt(i)) >>> 0
        }
        return hash
      }
      function getEdgePoint(fromEl, toEl) {
        const rectFrom = fromEl.getBoundingClientRect()
        const rectTo = toEl.getBoundingClientRect()
        const inset = 10 // 10px inside the div

        // Compute horizontal/vertical centers
        const fromCenterX =
          rectFrom.left + rectFrom.width / 2 + window.scrollX
        const fromCenterY =
          rectFrom.top + rectFrom.height / 2 + window.scrollY
        const toCenterX =
          rectTo.left + rectTo.width / 2 + window.scrollX
        const toCenterY =
          rectTo.top + rectTo.height / 2 + window.scrollY

        let x, y

        const dx = toCenterX - fromCenterX
        const dy = toCenterY - fromCenterY
        const absDx = Math.abs(dx)
        const absDy = Math.abs(dy)
        var side
        if (absDx > absDy) {
          // horizontal connection
          x =
            dx > 0 ?
              rectFrom.right - inset + window.scrollX
            : rectFrom.left + inset + window.scrollX
          y = fromCenterY
          side = "x"
        } else {
          // vertical connection
          side = "y"
          x = fromCenterX
          y =
            dy > 0 ?
              rectFrom.bottom - inset + window.scrollY
            : rectFrom.top + inset + window.scrollY
        }

        return { x, y, side }
      }
      function drawCurvedArrowEdge(fromEl, toEl) {
        const svg = document.getElementById("arrowsLayer")

        const start = getEdgePoint(fromEl, toEl)
        const end = getEdgePoint(toEl, fromEl) // target inset

        // perpendicular offset (smaller for short lines, bigger for longer)
        // const offset = Math.min(50, Math.sqrt(dx * dx + dy * dy) / 3)
        const rect = fromEl.getBoundingClientRect()
        const path = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "path",
        )
        const seed = hashStringToInt(
          fromEl.getAttribute("data-task-key"),
        ) // convert ID to number

        if (start.side === "x") {
          start.y += randomIntFromSeed(
            seed,
            -rect.height / 2,
            rect.height / 2,
          )
          end.y += randomIntFromSeed(
            seed + 1,
            -rect.height / 2,
            rect.height / 2,
          ) // different for end
        } else {
          start.x += randomIntFromSeed(
            seed,
            -rect.width / 2,
            rect.width / 2,
          )
          end.x += randomIntFromSeed(
            seed + 1,
            -rect.width / 2,
            rect.width / 2,
          )
        }
        path.setAttribute(
          "d",
          `M ${start.x},${start.y} ${end.x},${end.y}`,
        )
        path.setAttribute("stroke", "#de350b")
        path.setAttribute("stroke-width", "2")
        path.setAttribute("fill", "none")
        path.setAttribute("marker-end", "url(#arrowhead)")

        svg.appendChild(path)
      }
      function drawAllDependencies() {
        const svg = document.getElementById("arrowsLayer")
        svg.innerHTML = svg.querySelector("defs").outerHTML // reset but keep arrowhead

        document.querySelectorAll(".task").forEach((taskDiv) => {
          const taskKey = taskDiv.getAttribute("data-task-key")
          const task = tasks[taskKey]

          if (!task.blockedBy || task.blockedBy.length === 0) return

          task.blockedBy.forEach((blockerKey) => {
            const blockerDiv = document.querySelector(
              `[data-task-key="${blockerKey}"]`,
            )
            if (blockerDiv) drawCurvedArrowEdge(taskDiv, blockerDiv) // blocked â†’ blocker
          })
        })
      }
      window.addEventListener("resize", drawAllDependencies)
      function mulberry32(seed) {
        return function () {
          seed |= 0
          seed = (seed + 0x6d2b79f5) | 0
          let t = Math.imul(seed ^ (seed >>> 15), 1 | seed)
          t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t
          return ((t ^ (t >>> 14)) >>> 0) / 4294967296
        }
      }

      function randomIntFromSeed(seed, min, max) {
        return Math.floor(mulberry32(seed)() * (max - min + 1)) + min
      }

      // Add arrowhead marker
      const svg = document.getElementById("arrowsLayer")
      const marker = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "marker",
      )
      marker.setAttribute("id", "arrowhead")
      marker.setAttribute("markerWidth", "10")
      marker.setAttribute("markerHeight", "7")
      marker.setAttribute("refX", "0")
      marker.setAttribute("refY", "3.5")
      marker.setAttribute("orient", "auto")
      const polygon = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "polygon",
      )
      polygon.setAttribute("points", "0 0, 10 3.5, 0 7")
      polygon.setAttribute("fill", "red")
      marker.appendChild(polygon)
      svg.appendChild(marker)
    </script>
  </body>
</html>
